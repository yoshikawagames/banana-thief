<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>バナナを盗んで食え（エラー修正版2）</title>
    <!-- Tailwind CSSを読み込み -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
        body {
            font-family: 'Press+Start+2P', cursive;
            background-color: #f0f0f0;
        }
        canvas {
            border: 2px solid #333;
            /* 背景画像を元のものに戻します */
            background-image: linear-gradient(rgba(0, 0, 0, 0.4), rgba(0, 0, 0, 0.4)), url('https://raw.githubusercontent.com/yoshikawagames/banana-thief/main/%E3%83%90%E3%83%8A%E3%83%8A%E6%B3%A5%E6%A3%92%E8%83%8C%E6%99%AF%EF%BC%92.png'); 
            background-size: cover; 
            background-position: center; 
            background-repeat: no-repeat; 
            /* 画像が読み込めない場合の代替色を濃い緑に設定 */
            background-color: #228B22; 
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            max-width: 100%;
            display: block;
        }
        .pixel-art {
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
        }
        #game-title {
            font-size: 1.5rem;
        }
        @media (min-width: 768px) {
            #game-title {
                font-size: 2.5rem;
            }
        }
        .btn-green {
            background: linear-gradient(180deg, #10B981 0%, #059669 100%);
            border: 2px solid #065F46;
            color: white;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
        }
        .btn-red {
            background: linear-gradient(180deg, #EF4444 0%, #DC2626 100%);
            border: 2px solid #991B1B;
            color: white;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
        }
        .rhythm-lane-btn {
            padding: 2.5rem 4rem;
            border-radius: 0.5rem;
            font-size: 1.5rem; 
            font-weight: bold;
            color: white;
            transition: transform 0.2s;
            touch-action: none;
        }
        .rhythm-lane-btn:active {
            transform: scale(0.95);
        }
        /* リズム判定メッセージのスタイル */
        #hit-grade-display {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 3rem;
            font-weight: bold;
            color: white;
            text-shadow: 4px 4px 8px rgba(0, 0, 0, 0.7);
            pointer-events: none; 
            opacity: 0;
            transition: opacity 0.1s, transform 0.1s;
        }
        /* スコアリングメッセージのオーバーレイ */
        #game-message-overlay {
            background-color: rgba(0, 0, 0, 0.6); 
            border-radius: 0.75rem;
        }
        /* ジョイスティックコンテナ (モバイル/タブレット専用) - 画面右下に固定 */
        #joystick-container {
            position: fixed; 
            bottom: 50px; /* 画面下端から50px上 (プレイヤーの初期位置に近似) */
            right: 20px; 
            width: 170px; 
            height: 170px; 
            /* PCでは非表示 (デフォルト) */
            display: none; 
            z-index: 10;
        }
        /* 画面幅1024px以下でジョイスティックを表示 (iPad/タブレット対応) */
        @media (max-width: 1024px) { 
            #joystick-container {
                /* モバイル/タブレットでは表示 */
                display: block; 
            }
        }
    </style>
</head>
<body class="flex items-center justify-center min-h-screen p-4 bg-gray-100">
    <div class="flex flex-col items-center p-4 md:p-8 bg-gray-200 rounded-xl shadow-lg border-2 border-gray-300">
        <h1 id="game-title" class="text-2xl md:text-4xl text-gray-800 font-extrabold mb-4 text-center">バナナを盗んで食え</h1>
        
        <!-- ゲーム説明とタイトル画面 -->
        <div id="game-intro" class="text-center text-gray-700 mb-4 transition-opacity duration-500">
            <p class="mb-2">怪盗となり、美術館に展示されたバナナを盗み出せ！</p>
            <p class="mb-4">監視員の鋭い視線（弾幕）をかわし、バナナにたどり着くのだ。</p>
            
            <div class="mb-4">
                <label for="difficulty" class="text-gray-800 text-sm font-bold block mb-1">難易度選択:</label>
                <select id="difficulty" class="p-2 border border-gray-400 rounded-md bg-white">
                    <option value="easy">かんたん</option>
                    <option value="normal" selected>ふつう</option>
                </select>
            </div>
            
            <button id="startButton" class="btn-green p-4 rounded-xl text-lg md:text-xl font-bold hover:scale-105 transform transition duration-200">怪盗開始！</button>
        </div>
        
        <!-- ゲームキャンバス -->
        <div class="relative w-full h-[50vh] md:h-[70vh] flex justify-center items-center">
            <canvas id="gameCanvas" class="w-full h-full rounded-xl pixel-art"></canvas>
            
            <!-- スコアリング画面（ゲームオーバー/勝利）のオーバーレイ -->
            <p id="game-message-overlay" class="absolute inset-0 flex items-center justify-center text-center p-4 z-10 pointer-events-none text-white text-3xl md:text-4xl font-extrabold hidden" style="text-shadow: 4px 4px 8px rgba(0, 0, 0, 0.9);"></p>
            
            <!-- リズムゲームの説明画面 -->
            <div id="rhythm-intro-container" class="hidden absolute inset-0 flex flex-col items-center justify-center p-4">
                <p class="text-white font-bold mb-4 text-center p-4 bg-gray-800 bg-opacity-70 rounded-lg">バナナを食べるには、上から降ってくるノートが下の黄色いゾーンに来たら、対応するボタンを素早くタップしよう！</p>
                <div id="rhythm-intro-buttons" class="flex justify-around mt-4 w-1/2">
                    <!-- 説明用のボタンは削除し、テキストに集中 -->
                </div>
                <button id="rhythmStartButton" class="btn-green mt-8 p-4 rounded-xl text-lg md:text-xl font-bold hover:scale-105 transform transition duration-200">いただきます！</button>
            </div>

            <!-- リズムゲームの判定表示エリア -->
            <div id="hit-grade-display"></div>
        </div>

        <!-- ジョイスティックコンテナ (モバイル対応) -->
        <div id="joystick-container"></div>


        <!-- ゲーム中のUI要素 -->
        <div id="game-ui" class="mt-4 hidden w-full text-center">
            
            <!-- 勝利条件: バナナを食べるボタン -->
            <div id="eat-banana-container" class="hidden flex flex-col items-center">
                <!-- リズムゲームのライフ表示を追加 -->
                <p id="eat-count-display" class="text-lg mb-2 text-gray-700">食べたバナナ... 0/10</p>
                <p id="rhythm-life-display" class="text-lg mb-2 text-red-600 font-bold hidden"></p>
                
                <div id="rhythm-game-container" class="mt-4">
                    <button id="laneButtonLeft" class="rhythm-lane-btn bg-yellow-500 hover:bg-yellow-600 focus:bg-yellow-700">←</button>
                    <button id="laneButtonCenter" class="rhythm-lane-btn bg-yellow-500 hover:bg-yellow-600 focus:bg-yellow-700">・</button>
                    <button id="laneButtonRight" class="rhythm-lane-btn bg-yellow-500 hover:bg-yellow-600 focus:bg-yellow-700">→</button>
                </div>
            </div>
            
            <!-- ゲームオーバー/クリア後のボタン -->
            <button id="retryButton" class="btn-red p-4 rounded-xl text-lg md:text-xl font-bold hover:scale-105 transform transition duration-200 hidden">リトライ</button>
        </div>
    </div>

    <!-- nipplejsライブラリの読み込み -->
    <script src="https://unpkg.com/nipplejs@0.8.0/dist/nipplejs.min.js"></script>
    <script>
        window.onload = function() {
            const canvas = document.getElementById('gameCanvas');
            const ctx = canvas.getContext('2d');
            
            // BGM関連の変数
            const BGM_URL = 'https://raw.githubusercontent.com/yoshikawagames/banana-thief/main/bananasong.mp3'; 
            let gameBGM = null; 
            let bgmReady = false; 
            
            // UI要素を取得
            const startButton = document.getElementById('startButton');
            const retryButton = document.getElementById('retryButton');
            const gameIntro = document.getElementById('game-intro');
            const gameUI = document.getElementById('game-ui');
            const gameMessageOverlay = document.getElementById('game-message-overlay'); 
            const eatBananaContainer = document.getElementById('eat-banana-container');
            const eatCountDisplay = document.getElementById('eat-count-display');
            const difficultySelect = document.getElementById('difficulty');
            const rhythmIntroContainer = document.getElementById('rhythm-intro-container');
            const rhythmStartButton = document.getElementById('rhythmStartButton');
            const hitGradeDisplay = document.getElementById('hit-grade-display'); 
            const joystickContainer = document.getElementById('joystick-container'); 
            
            // --- 修正点1: 頻繁にアクセスされるリズムゲームUI要素をキャッシュ ---
            const rhythmGameContainer = document.getElementById('rhythm-game-container');
            const rhythmLifeDisplay = document.getElementById('rhythm-life-display');
            
            // リズムゲームのレーンボタンを取得
            const laneButtonLeft = document.getElementById('laneButtonLeft');
            const laneButtonCenter = document.getElementById('laneButtonCenter');
            const laneButtonRight = document.getElementById('laneButtonRight');
            
            // 入力状態
            let keys = {};
            // ジョイスティック変数
            let joystick = {
                active: false,
                deltaX: 0, 
                deltaY: 0,
                radius: 60, 
                innerRadius: 25 
            };
            const JOYSTICK_DEADZONE = 5; 
            
            let animationFrameId;
            let startTime;
            let endTime;
            
            // グローバルなゲーム設定
            let gameState = 'title'; 
            let player = { x: 0, y: 0, size: 20, speed: 5 };

            const banana = { x: 0, y: 0, width: 30, height: 60 };
            const eatMax = 10; 
            
            const guards = [
                { x: 0, y: 0, size: 30, color: '#3B82F6' },
                { x: 0, y: 0, size: 30, color: '#3B82F6' }
            ];
            const visitors = [
                { x: 0, y: 0, size: 20, color: '#9CA3AF' },
                { x: 0, y: 0, size: 20, color: '#9CA3AF' },
                { x: 0, y: 0, size: 20, color: '#9CA3AF' }
            ];
            let bullets = []; 
            let bulletSpeed = 2.0; 
            let bulletInterval = 50; 
            let visitorBulletInterval = 120;
            let visitorBulletDirection = []; 
            let frameCount = 0;
            const bulletSize = 10;
            let initialBulletFired = false;
            
            let gameFlashTimer = 0; 
            
            // --- リズムゲーム変数 ---
            let rhythmNotes = [];
            const RHYTHM_NOTE_SPEED = 2.0; 
            
            const hitZoneHeight = 50;
            let rhythmHitZoneY; 
            const hitZoneColor = 'rgba(255, 204, 0, 0.5)';
            const rhythmLanes = ['left', 'center', 'right'];
            let rhythmScore = 0;
            let rhythmGameMisses = 0;
            const rhythmMaxMisses = 3; 

            // 判定表示用
            let lastHitGrade = '';
            let hitGradeTimer = 0;
            
            // キャンバスの縦横比を設定
            function resizeCanvas() {
                const maxWidth = window.innerWidth > 768 ? 800 : window.innerWidth * 0.9;
                canvas.width = maxWidth;
                canvas.height = maxWidth * 1.0; 
                rhythmHitZoneY = canvas.height - 150; 
            }
            window.addEventListener('resize', resizeCanvas);
            resizeCanvas();

            // BGMの初期化
            function initBGM() {
                if (!gameBGM) {
                    gameBGM = new Audio(BGM_URL);
                    gameBGM.loop = true;
                    gameBGM.preload = 'auto';
                    gameBGM.volume = 0.4;
                    gameBGM.oncanplaythrough = () => {
                        bgmReady = true;
                        console.log("BGM ready.");
                    };
                    gameBGM.onerror = (e) => {
                        console.error("BGM load error:", e);
                        bgmReady = false;
                    };
                }
            }

            // BGM再生
            function playBGM() {
                // --- 修正点2: gameBGMがnullでないことを明示的に確認 ---
                if (gameBGM && bgmReady && gameBGM.paused) {
                    gameBGM.play().catch(e => console.log("BGM play failed (user interaction required or other error):", e));
                }
            }

            // BGM停止
            function stopBGM() {
                if (gameBGM) {
                    gameBGM.pause();
                    gameBGM.currentTime = 0;
                }
            }
            
            // ジョイスティックの初期化
            function initJoystick() {
                // nipplejs (ジョイスティックライブラリ)
                // ロードが失敗した場合に備えてnipplejsの存在を確認
                if (typeof nipplejs === 'undefined') {
                    console.error("NippleJS library not loaded. Joystick disabled.");
                    return; 
                }

                const manager = nipplejs.create({
                    zone: joystickContainer,
                    mode: 'static', 
                    position: { left: '50%', top: '50%' }, 
                    color: '#10b981', 
                    lockX: false, 
                    lockY: false 
                });

                manager.on('move', function(evt, data) {
                    joystick.active = true;
                    if (data.vector) {
                        // nipplejsのベクトルをそのまま使用
                        joystick.deltaX = data.vector.x * joystick.radius;
                        joystick.deltaY = -data.vector.y * joystick.radius; // Y軸は上向きを正に反転
                    }
                }).on('end', function(evt) {
                    joystick.active = false;
                    joystick.deltaX = 0;
                    joystick.deltaY = 0;
                });
            }

            // プレイヤーの移動処理（モバイル/キーボード対応）
            function movePlayer() {
                let dx = 0;
                let dy = 0;

                // 1. キーボード入力 (PC向け)
                if (keys['arrowup'] || keys['w']) dy -= 1;
                if (keys['arrowdown'] || keys['s']) dy += 1;
                if (keys['arrowleft'] || keys['a']) dx -= 1;
                if (keys['arrowright'] || keys['d']) dx += 1;

                // 2. ジョイスティック入力 (モバイル向け)
                if (joystick.active) {
                    const diffX = joystick.deltaX;
                    const diffY = joystick.deltaY;
                    let distance = Math.sqrt(diffX * diffX + diffY * diffY);

                    if (distance > JOYSTICK_DEADZONE) {
                        const displacementRatio = (distance - JOYSTICK_DEADZONE) / (joystick.radius - JOYSTICK_DEADZONE);
                        const scaledRatio = Math.min(1, Math.max(0, displacementRatio)); 

                        const directionX = diffX / distance;
                        const directionY = diffY / distance;
                        
                        dx += directionX * scaledRatio;
                        dy += directionY * scaledRatio;
                    }
                }

                // 移動の適用
                if (dx !== 0 || dy !== 0) {
                    const length = Math.sqrt(dx * dx + dy * dy);
                    if (length > 1) { 
                        dx /= length;
                        dy /= length;
                    }
                    player.x += dx * player.speed;
                    player.y += dy * player.speed;
                }

                // 画面端の境界チェック
                player.x = Math.max(player.size / 2, Math.min(canvas.width - player.size / 2, player.x));
                player.y = Math.max(player.size / 2, Math.min(canvas.height - player.size / 2, player.y));
            }

            // ゲームの初期状態を設定
            function initGame() {
                const difficulty = difficultySelect.value;
                
                if (difficulty === 'easy') {
                    bulletSpeed = 1.5; 
                    bulletInterval = 60; 
                    visitorBulletInterval = 150; 
                    player.speed = 6;
                } else if (difficulty === 'normal') {
                    bulletSpeed = 2.0; 
                    bulletInterval = 40; 
                    visitorBulletInterval = 100; 
                    player.speed = 5;
                }

                player.x = canvas.width / 2;
                player.y = canvas.height - 50; 
                
                banana.x = canvas.width / 2 - banana.width / 2;
                banana.y = 50;
                
                guards[0].x = canvas.width / 4; guards[0].y = 100;
                guards[1].x = canvas.width * 3 / 4; guards[1].y = 100;
                
                visitors[0].x = canvas.width / 8; visitors[0].y = canvas.height / 2;
                visitors[1].x = canvas.width / 2; visitors[1].y = canvas.height / 2.5;
                visitors[2].x = canvas.width * 7 / 8; visitors[2].y = canvas.height / 2;

                bullets = []; rhythmNotes = []; 
                rhythmScore = 0; rhythmGameMisses = 0; 

                frameCount = 0; initialBulletFired = false; gameFlashTimer = 0; 
                startTime = performance.now();

                visitorBulletDirection = visitors.map(() => {
                    const angle = Math.random() * Math.PI * 2;
                    return { dx: Math.cos(angle), dy: Math.sin(angle) };
                });
            }
            
            // --- 描画関数群 ---

            function drawPlayer() {
                const s = player.size / 4; 
                const x = player.x - player.size / 2;
                const y = player.y - player.size / 2;
                
                ctx.strokeStyle = '#FFFFFF'; 
                ctx.lineWidth = 2; 
                ctx.strokeRect(x - 1, y - 1, player.size + 2, player.size + 2);

                ctx.fillStyle = '#000000'; 
                ctx.fillRect(x, y, s * 4, s * 2);
                ctx.fillRect(x + s, y + s * 2, s * 2, s);
                ctx.fillStyle = '#C0C0C0'; 
                ctx.fillRect(x + s, y + s * 3, s * 2, s);
                
                ctx.fillStyle = '#333333'; 
                ctx.fillRect(x + s, y + s * 4, s * 2, s * 3);
                ctx.fillRect(x, y + s * 5, s, s);
                ctx.fillRect(x + s * 3, y + s * 5, s, s);
            }
            function drawGuards() {
                guards.forEach(guard => {
                    const s = guard.size / 4;
                    const x = guard.x - guard.size / 2;
                    const y = guard.y - guard.size / 2;
                    
                    ctx.strokeStyle = '#FFFFFF'; 
                    ctx.lineWidth = 2; 
                    ctx.strokeRect(x - 1, y - 1, guard.size + 2, guard.size + 2);

                    ctx.fillStyle = '#0000FF'; 
                    ctx.fillRect(x, y, s * 4, s * 2);
                    
                    ctx.fillStyle = '#E6E6E6';
                    ctx.fillRect(x + s, y + s * 2, s * 2, s * 2);
                    
                    ctx.fillStyle = '#0000FF'; 
                    ctx.fillRect(x, y + s * 4, s * 4, s * 3);
                });
            }
            function drawVisitors() {
                visitors.forEach(visitor => {
                    const s = visitor.size / 4;
                    const x = visitor.x - visitor.size / 2;
                    const y = visitor.y - visitor.size / 2;
                    
                    ctx.strokeStyle = '#FFFFFF'; 
                    ctx.lineWidth = 2; 
                    ctx.strokeRect(x - 1, y - 1, visitor.size + 2, visitor.size + 2);
                    
                    ctx.fillStyle = visitor.color;
                    ctx.fillRect(x, y + s * 3, s * 4, s * 4);
                    
                    ctx.fillStyle = '#F08080';
                    ctx.fillRect(x + s, y, s * 2, s * 2);
                });
            }
            function drawBanana() {
                const x = banana.x;
                const y = banana.y;
                const w = banana.width;
                const h = banana.height;

                ctx.fillStyle = '#A8A29E'; 
                ctx.fillRect(x, y, w, h / 10);
                
                ctx.fillStyle = '#FDE047'; 
                ctx.fillRect(x + w / 4, y + h / 10, w / 2, h * 0.9);
                ctx.fillRect(x + w * 0.2, y + h * 0.3, w * 0.6, h * 0.4);

                ctx.fillStyle = '#EAB308'; 
                ctx.fillRect(x + w * 0.5, y + h * 0.2, w * 0.1, h * 0.7);
            }
            function drawBullets() {
                bullets.forEach(bullet => {
                    ctx.strokeStyle = '#000000'; 
                    ctx.lineWidth = 2; 

                    ctx.fillStyle = '#EF4444'; 
                    ctx.beginPath();
                    ctx.moveTo(bullet.x, bullet.y);
                    ctx.lineTo(bullet.x + bullet.width, bullet.y + bullet.height / 2);
                    ctx.lineTo(bullet.x, bullet.y + bullet.height);
                    ctx.closePath(); 
                    ctx.fill();
                    ctx.stroke(); 
                });
            }
            function createInitialBullet() {
                if (frameCount === 30 && !initialBulletFired) {
                    const dx1 = player.x - guards[0].x;
                    const dy1 = player.y - guards[0].y;
                    const angle1 = Math.atan2(dy1, dx1);
                    bullets.push({
                        x: guards[0].x, y: guards[0].y,
                        dx: Math.cos(angle1) * bulletSpeed * 1.5,
                        dy: Math.sin(angle1) * bulletSpeed * 1.5,
                        width: bulletSize, height: bulletSize
                    });
                    
                    const dx2 = player.x - guards[1].x;
                    const dy2 = player.y - guards[1].y;
                    const angle2 = Math.atan2(dy2, dx2);
                    bullets.push({
                        x: guards[1].x, y: guards[1].y,
                        dx: Math.cos(angle2) * bulletSpeed * 1.5,
                        dy: Math.sin(angle2) * bulletSpeed * 1.5,
                        width: bulletSize, height: bulletSize
                    });
                    initialBulletFired = true;
                }
            }

            function createGuardBulletPattern() {
                const difficulty = difficultySelect.value;
                if (difficulty === 'normal') {
                    if (frameCount % (bulletInterval * 2) === 0) {
                        const angle = Math.PI * 0.5;
                        const spread = 0.2;
                        guards.forEach(guard => {
                            for(let i = -1; i <= 1; i++) {
                                const bulletAngle = angle + (i * spread);
                                bullets.push({
                                    x: guard.x, y: guard.y,
                                    dx: Math.cos(bulletAngle) * bulletSpeed * 1.5,
                                    dy: Math.sin(bulletAngle) * bulletSpeed * 1.5,
                                    width: bulletSize, height: bulletSize
                                });
                            }
                        });
                    }
                }
                if (frameCount % bulletInterval === 0) {
                    const angleStep = Math.PI * 2 / 10;
                    guards.forEach(guard => {
                        for (let i = 0; i < 10; i++) {
                            const angle = i * angleStep;
                            bullets.push({
                                x: guard.x, y: guard.y,
                                dx: Math.cos(angle) * bulletSpeed,
                                dy: Math.sin(angle) * bulletSpeed,
                                width: bulletSize, height: bulletSize
                            });
                        }
                    });
                }
            }

            function createVisitorBulletPattern() {
                if (frameCount % visitorBulletInterval === 0) {
                    visitors.forEach((visitor, index) => {
                        const dx = visitorBulletDirection[index].dx * bulletSpeed * 1.2;
                        const dy = visitorBulletDirection[index].dy * bulletSpeed * 1.2;
                        
                        bullets.push({
                            x: visitor.x, y: visitor.y,
                            dx: dx, dy: dy,
                            width: bulletSize, height: bulletSize
                        });
                    });
                }
            }

            function moveBullets() {
                bullets.forEach(bullet => {
                    bullet.x += bullet.dx;
                    bullet.y += bullet.dy;
                });
                bullets = bullets.filter(bullet =>
                    bullet.x > -bulletSize && bullet.x < canvas.width + bulletSize &&
                    bullet.y > -bulletSize && bullet.y < canvas.height + bulletSize
                );
            }

            function checkCollision() {
                for (const bullet of bullets) {
                    const dx = player.x - (bullet.x + bullet.width / 2);
                    const dy = player.y - (bullet.y + bullet.height / 2);
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    if (distance < player.size / 2 + bullet.width / 2) {
                        return true;
                    }
                }
                return false;
            }
            
            function checkBananaProximity() {
                const dx = player.x - (banana.x + banana.width / 2);
                const dy = player.y - (banana.y + banana.height / 2);
                const distance = Math.sqrt(dx * dx + dy * dy);
                return distance < player.size + 20;
            }
            
            function moveRhythmNotes() {
                const noteSpeed = RHYTHM_NOTE_SPEED; 
                
                rhythmNotes.forEach(note => {
                    note.y += noteSpeed;
                });

                let notesPassed = false;
                rhythmNotes = rhythmNotes.filter(note => {
                    // ノートが判定ゾーンを大きく通り過ぎたらミス（ライフ減少）
                    if (note.y > rhythmHitZoneY + hitZoneHeight + 20) { 
                        notesPassed = true;
                        return false;
                    }
                    return true;
                });
                
                if (notesPassed) {
                    rhythmGameMisses++;
                    gameFlashTimer = 15; 
                    lastHitGrade = 'MISS';
                    hitGradeTimer = 45;

                    updateRhythmLifeDisplay();

                    if (rhythmGameMisses >= rhythmMaxMisses) {
                         gameState = 'gameOver';
                         endTime = performance.now();
                    }
                }
            }

            function drawRhythmGame() {
                ctx.fillStyle = hitZoneColor;
                ctx.fillRect(0, rhythmHitZoneY, canvas.width, hitZoneHeight);
                
                // レーンの区切り線
                const laneWidth = canvas.width / 3;
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.7)';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(laneWidth, rhythmHitZoneY);
                ctx.lineTo(laneWidth, canvas.height);
                ctx.moveTo(laneWidth * 2, rhythmHitZoneY);
                ctx.lineTo(laneWidth * 2, canvas.height);
                ctx.stroke();

                ctx.fillStyle = '#6D28D9';
                rhythmNotes.forEach(note => {
                    ctx.fillRect(note.x - note.size / 2, note.y - note.size / 2, note.size, note.size);
                });
            }

            function generateRhythmNotes() {
                rhythmNotes = []; 
                const noteCount = eatMax;
                const noteSpacing = 80; 
                const laneWidth = canvas.width / 3;

                // ランダムなノーツを生成
                for(let i = 0; i < noteCount; i++) {
                    const laneIndex = Math.floor(Math.random() * rhythmLanes.length);
                    const noteX = laneWidth * laneIndex + (laneWidth / 2);
                    const noteY = -i * noteSpacing; 
                    
                    rhythmNotes.push({
                        x: noteX,
                        y: noteY,
                        lane: rhythmLanes[laneIndex],
                        size: 20
                    });
                }
                
                // 食べたバナナの表示を更新
                eatCountDisplay.textContent = `食べたバナナ... ${rhythmScore}/${eatMax}`;
                updateRhythmLifeDisplay();
            }

            function handleRhythmTap(lane) {
                if (gameState !== 'rhythm') return;

                let bestHit = null;
                let bestDistance = Infinity;
                const hitThreshold = 30; // 判定のしきい値

                for (let i = 0; i < rhythmNotes.length; i++) {
                    const note = rhythmNotes[i];
                    if (note.lane === lane) {
                        const distance = Math.abs(note.y - (rhythmHitZoneY + hitZoneHeight / 2));
                        if (distance < hitThreshold && distance < bestDistance) {
                            bestDistance = distance;
                            bestHit = i;
                        }
                    }
                }

                if (bestHit !== null) {
                    rhythmNotes.splice(bestHit, 1);
                    rhythmScore++;
                    
                    if (rhythmScore >= eatMax) {
                        gameState = 'win';
                        endTime = performance.now();
                    }
                    
                    eatCountDisplay.textContent = `食べたバナナ... ${rhythmScore}/${eatMax}`;
                    
                    // 判定表示ロジック
                    if (bestDistance < 10) {
                        lastHitGrade = 'PERFECT!';
                    } else if (bestDistance < 20) {
                        lastHitGrade = 'GREAT!';
                    } else {
                        lastHitGrade = 'GOOD';
                    }
                    hitGradeTimer = 45; 
                } else {
                    // ミス判定 (空タップ)
                    rhythmGameMisses++;
                    gameFlashTimer = 15; 
                    lastHitGrade = 'MISS';
                    hitGradeTimer = 45;
                    updateRhythmLifeDisplay();
                    
                    if (rhythmGameMisses >= rhythmMaxMisses) {
                         gameState = 'gameOver';
                         endTime = performance.now();
                    }
                }
            }
            
            function updateRhythmLifeDisplay() {
                const remaining = rhythmMaxMisses - rhythmGameMisses;
                rhythmLifeDisplay.textContent = `失敗回数: ${rhythmGameMisses}/${rhythmMaxMisses} (残り: ${remaining})`;
            }

            // --- メインゲームループ ---
            function gameLoop() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                frameCount++;

                if (gameState === 'playing') {
                    // BGMの再生を開始
                    playBGM();
                    
                    movePlayer();
                    drawBanana();
                    drawGuards();
                    drawVisitors();
                    
                    // プレイヤーの点滅表示
                    if (gameFlashTimer > 0) {
                        gameFlashTimer--;
                        if (frameCount % 4 < 2) { // プレイヤーを点滅させる
                            drawPlayer();
                        }
                    } else {
                        drawPlayer();
                    }

                    // 弾丸の生成と移動
                    createInitialBullet();
                    createGuardBulletPattern();
                    createVisitorBulletPattern();
                    moveBullets();
                    drawBullets();

                    // 衝突判定
                    if (checkCollision() && gameFlashTimer === 0) {
                        gameState = 'gameOver';
                        endTime = performance.now();
                    }
                    
                    // バナナの近くにいるか判定
                    if (checkBananaProximity()) {
                        eatBananaContainer.classList.remove('hidden');
                        // --- 修正点1: キャッシュした変数を使用 ---
                        rhythmGameContainer.classList.add('hidden');
                        rhythmLifeDisplay.classList.add('hidden');
                        
                        // 近くにいる状態で確定ボタンを押したらリズムゲームへ
                        if (keys[' '] || keys['enter']) {
                            gameState = 'rhythm_intro';
                            keys[' '] = false; // 連続入力防止
                            keys['enter'] = false;
                        }
                    } else {
                        eatBananaContainer.classList.add('hidden');
                    }

                } else if (gameState === 'rhythm_intro') {
                    // 何も描画しない（UIがオーバーレイとして表示されるため）
                } 
                
                else if (gameState === 'rhythm') {
                    moveRhythmNotes();
                    drawRhythmGame();
                    
                    // 判定メッセージの描画
                    if (hitGradeTimer > 0) {
                        hitGradeTimer--;
                        hitGradeDisplay.textContent = lastHitGrade;
                        hitGradeDisplay.style.opacity = hitGradeTimer / 45; 
                        hitGradeDisplay.style.transform = `translate(-50%, -50%) scale(${1 + (45 - hitGradeTimer) / 100})`;
                    } else {
                         hitGradeDisplay.style.opacity = 0;
                    }

                } else if (gameState === 'gameOver' || gameState === 'win') {
                    stopBGM();
                    drawBanana();
                    drawGuards();
                    drawVisitors();
                    drawBullets(); // 最後の状態を描画
                    
                    // 結果メッセージを表示
                    gameMessageOverlay.classList.remove('hidden');
                    retryButton.classList.remove('hidden');
                    
                    if (gameState === 'gameOver') {
                        gameMessageOverlay.textContent = 'GAME OVER\n監視員に見つかった！';
                    } else {
                        const timeTaken = ((endTime - startTime) / 1000).toFixed(2);
                        gameMessageOverlay.textContent = `CLEAR!\nバナナゲット！\nタイム: ${timeTaken}秒`;
                    }
                }
                
                animationFrameId = requestAnimationFrame(gameLoop);
            }

            // --- イベントリスナー ---

            // タイトル画面からゲーム開始
            startButton.addEventListener('click', () => {
                gameIntro.classList.add('hidden');
                gameUI.classList.remove('hidden');
                initGame();
                gameState = 'playing';
            });
            
            // リズムゲームの説明画面から開始
            rhythmStartButton.addEventListener('click', () => {
                rhythmIntroContainer.classList.add('hidden');
                // --- 修正点1: キャッシュした変数を使用 ---
                rhythmGameContainer.classList.remove('hidden');
                rhythmLifeDisplay.classList.remove('hidden');
                generateRhythmNotes(); 
                gameState = 'rhythm';
            });

            // リトライボタン
            retryButton.addEventListener('click', () => {
                gameMessageOverlay.classList.add('hidden');
                retryButton.classList.add('hidden');
                gameIntro.classList.remove('hidden');
                gameUI.classList.add('hidden');
                gameState = 'title';
            });
            
            // リズムゲームボタンのイベントリスナー (PC/モバイル)
            laneButtonLeft.addEventListener('pointerdown', (e) => { e.preventDefault(); handleRhythmTap('left'); });
            laneButtonCenter.addEventListener('pointerdown', (e) => { e.preventDefault(); handleRhythmTap('center'); });
            laneButtonRight.addEventListener('pointerdown', (e) => { e.preventDefault(); handleRhythmTap('right'); });
            
            // キーボード入力
            document.addEventListener('keydown', (e) => {
                keys[e.key.toLowerCase()] = true;
                
                if (gameState === 'rhythm') {
                    e.preventDefault();
                    if (e.key === 'ArrowLeft' || e.key.toLowerCase() === 'a') {
                        handleRhythmTap('left');
                    } else if (e.key === 'ArrowDown' || e.key.toLowerCase() === 's') {
                        handleRhythmTap('center');
                    } else if (e.key === 'ArrowRight' || e.key.toLowerCase() === 'd') {
                        handleRhythmTap('right');
                    }
                } else if (gameState === 'playing' && (e.key === ' ' || e.key === 'Enter') && checkBananaProximity()) {
                    gameState = 'rhythm_intro';
                    rhythmIntroContainer.classList.remove('hidden');
                    eatBananaContainer.classList.add('hidden');
                }
            });
            document.addEventListener('keyup', (e) => {
                keys[e.key.toLowerCase()] = false;
            });

            // ゲーム初期化
            initBGM();
            initJoystick();
            gameLoop();
        };
    </script>
</body>
</html>
