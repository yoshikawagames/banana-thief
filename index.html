<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ãƒãƒŠãƒŠã‚’ç›—ã‚“ã§é£Ÿãˆ</title>
    <!-- Tailwind CSSã‚’èª­ã¿è¾¼ã¿ -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
        body {
            font-family: 'Press Start 2P', cursive;
            background-color: #f0f0f0;
        }
        canvas {
            border: 2px solid #333;

            /* --- èƒŒæ™¯ç”»åƒã®è¨­å®š (æ–°ã—ã„ã‚¤ãƒ©ã‚¹ãƒˆã«å·®ã—æ›¿ãˆã¾ã—ãŸ) --- */
            /* âš ï¸ ç”»åƒç›´ãƒªãƒ³ã‚¯ã®å‰ã«é»’ã®åŠé€æ˜ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼(rgba(0, 0, 0, 0.4))ã‚’è¿½åŠ ã—ã¦ã„ã¾ã™ */
            background-image: linear-gradient(rgba(0, 0, 0, 0.4), rgba(0, 0, 0, 0.4)), url('https://raw.githubusercontent.com/yoshikawagames/banana-thief/main/%E3%83%90%E3%83%8A%E3%83%8A%E6%B3%A5%E6%A3%92%E8%83%8C%E6%99%AF%EF%BC%92.png'); 
            
            background-size: cover; /* ã‚­ãƒ£ãƒ³ãƒã‚¹ã«åˆã‚ã›ã¦ç”»åƒã‚’æ‹¡å¤§ãƒ»ç¸®å° */
            background-position: center; /* ç”»åƒã‚’ä¸­å¤®ã«é…ç½® */
            background-repeat: no-repeat; /* ç”»åƒã®ç¹°ã‚Šè¿”ã—ã‚’é˜²æ­¢ */
            background-color: #4A4A4A; /* ç”»åƒãŒèª­ã¿è¾¼ã‚ãªã‹ã£ãŸå ´åˆã®ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ */
            /* --------------------- */

            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            max-width: 100%;
            display: block;
        }
        .pixel-art {
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
        }
        #game-title {
            font-size: 1.5rem;
        }
        @media (min-width: 768px) {
            #game-title {
                font-size: 2.5rem;
            }
        }
        .btn-green {
            background: linear-gradient(180deg, #10B981 0%, #059669 100%);
            border: 2px solid #065F46;
            color: white;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
        }
        .btn-red {
            background: linear-gradient(180deg, #EF4444 0%, #DC2626 100%);
            border: 2px solid #991B1B;
            color: white;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
        }
        .btn-yellow {
            background: linear-gradient(180deg, #FDE047 0%, #EAB308 100%);
            border: 2px solid #A16207;
            color: #4B5563;
            text-shadow: 1px 1px 2px rgba(255,255,255,0.5);
        }
        #joystick {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 100px;
            height: 100px;
            /* ã‚¸ãƒ§ã‚¤ã‚¹ãƒ†ã‚£ãƒƒã‚¯ã¯ç™½ */
            background-color: rgba(255, 255, 255, 0.3); 
            border: 2px solid rgba(0, 0, 0, 0.5); /* é»’ã„ç¸ã‚’è¿½åŠ  */
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            opacity: 0.8;
            touch-action: none; /* Disable touch gestures */
        }
        #joystick-handle {
            width: 50px;
            height: 50px;
            /* ãƒãƒ³ãƒ‰ãƒ«ã‚‚ç™½ */
            background-color: rgba(255, 255, 255, 0.7); 
            border-radius: 50%;
        }
        #rhythm-game-container {
            display: flex;
            justify-content: space-around;
            width: 100%;
            margin-top: 1rem;
        }
        /* ãƒªã‚ºãƒ ã‚²ãƒ¼ãƒ æœ¬ç•ªã®ãƒœã‚¿ãƒ³ */
        .rhythm-lane-btn {
            padding: 2.5rem 4rem;
            border-radius: 0.5rem;
            font-size: 1.5rem; 
            font-weight: bold;
            color: white;
            transition: transform 0.2s;
            touch-action: none;
        }
        .rhythm-lane-btn:active {
            transform: scale(0.95);
        }
        /* èª¬æ˜ç”»é¢ã®ãƒœã‚¿ãƒ³ */
        .rhythm-intro-btn {
            padding: 1rem 2rem;
            border-radius: 0.5rem;
            font-size: 1rem;
            font-weight: bold;
            color: white;
            transition: transform 0.2s;
            touch-action: none;
        }
        #rhythm-intro-container {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(255, 255, 255, 0.9);
            padding: 2rem;
            border-radius: 1rem;
            text-align: center;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
        }
    </style>
</head>
<body class="flex items-center justify-center min-h-screen p-4 bg-gray-100">
    <div class="flex flex-col items-center p-4 md:p-8 bg-gray-200 rounded-xl shadow-lg border-2 border-gray-300">
        <h1 id="game-title" class="text-2xl md:text-4xl text-gray-800 font-extrabold mb-4 text-center">ãƒãƒŠãƒŠã‚’ç›—ã‚“ã§é£Ÿãˆ</h1>
        
        <!-- ã‚²ãƒ¼ãƒ èª¬æ˜ã¨ã‚¿ã‚¤ãƒˆãƒ«ç”»é¢ -->
        <div id="game-intro" class="text-center text-gray-700 mb-4 transition-opacity duration-500">
            <p class="mb-2">æ€ªç›—ã¨ãªã‚Šã€ç¾è¡“é¤¨ã«å±•ç¤ºã•ã‚ŒãŸãƒãƒŠãƒŠã‚’ç›—ã¿å‡ºã›ï¼</p>
            <p class="mb-4">ç›£è¦–å“¡ã®é‹­ã„è¦–ç·šï¼ˆå¼¾å¹•ï¼‰ã‚’ã‹ã‚ã—ã€ãƒãƒŠãƒŠã«ãŸã©ã‚Šç€ãã®ã ã€‚</p>
            
            <div class="mb-4">
                <label for="difficulty" class="text-gray-800 text-sm font-bold block mb-1">é›£æ˜“åº¦é¸æŠ:</label>
                <select id="difficulty" class="p-2 border border-gray-400 rounded-md bg-white">
                    <option value="easy">ã‹ã‚“ãŸã‚“</option>
                    <option value="normal" selected>ãµã¤ã†</option>
                    <option value="hard">ã‚€ãšã‹ã—ã„</option>
                    <option value="debug">ãƒ‡ãƒãƒƒã‚°</option>
                </select>
            </div>
            
            <button id="startButton" class="btn-green p-4 rounded-xl text-lg md:text-xl font-bold hover:scale-105 transform transition duration-200">æ€ªç›—é–‹å§‹ï¼</button>
        </div>
        
        <!-- ã‚²ãƒ¼ãƒ ã‚­ãƒ£ãƒ³ãƒã‚¹ -->
        <div class="relative w-full h-[50vh] md:h-[70vh] flex justify-center items-center">
            <canvas id="gameCanvas" class="w-full h-full rounded-xl pixel-art"></canvas>
            <div id="joystick" class="hidden">
                <div id="joystick-handle"></div>
            </div>
            
            <!-- ãƒªã‚ºãƒ ã‚²ãƒ¼ãƒ ã®èª¬æ˜ç”»é¢ -->
            <div id="rhythm-intro-container" class="hidden">
                <p class="text-gray-800 font-bold mb-4">ãƒãƒŠãƒŠã‚’é£Ÿã¹ã‚‹ã«ã¯ã€ä¸Šã‹ã‚‰é™ã£ã¦ãã‚‹ãƒãƒ¼ãƒˆãŒä¸‹ã®é»„è‰²ã„ã‚¾ãƒ¼ãƒ³ã«æ¥ãŸã‚‰ã€å¯¾å¿œã™ã‚‹ãƒœã‚¿ãƒ³ã‚’ç´ æ—©ãã‚¿ãƒƒãƒ—ã—ã‚ˆã†ï¼</p>
                <div id="rhythm-intro-buttons" class="flex justify-around mt-4">
                    <!-- èª¬æ˜ç”»é¢ã®ãƒœã‚¿ãƒ³ã«ã¯åˆ¥ã®ã‚¯ãƒ©ã‚¹ã‚’é©ç”¨ -->
                    <button class="rhythm-intro-btn bg-yellow-500 text-white">â†</button>
                    <button class="rhythm-intro-btn bg-yellow-500 text-white">ãƒ»</button>
                    <button class="rhythm-intro-btn bg-yellow-500 text-white">â†’</button>
                </div>
                <button id="rhythmStartButton" class="btn-green mt-4 p-4 rounded-xl text-lg md:text-xl font-bold hover:scale-105 transform transition duration-200">ã„ãŸã ãã¾ã™ï¼</button>
            </div>
        </div>
        
        <!-- ã‚²ãƒ¼ãƒ ä¸­ã®UIè¦ç´  -->
        <div id="game-ui" class="mt-4 hidden w-full text-center">
            <p id="game-message" class="text-xl md:text-2xl text-gray-800 font-bold mb-4"></p>
            
            <!-- å‹åˆ©æ¡ä»¶: ãƒãƒŠãƒŠã‚’é£Ÿã¹ã‚‹ãƒœã‚¿ãƒ³ -->
            <div id="eat-banana-container" class="hidden flex flex-col items-center">
                <p id="eat-count-display" class="text-lg mb-2 text-gray-700">é£Ÿã¹ãŸãƒãƒŠãƒŠ... 0/10</p>
                <div id="rhythm-game-container" class="mt-4">
                    <button id="laneButtonLeft" class="rhythm-lane-btn bg-yellow-500 hover:bg-yellow-600 focus:bg-yellow-700">â†</button>
                    <button id="laneButtonCenter" class="rhythm-lane-btn bg-yellow-500 hover:bg-yellow-600 focus:bg-yellow-700">ãƒ»</button>
                    <button id="laneButtonRight" class="rhythm-lane-btn bg-yellow-500 hover:bg-yellow-600 focus:bg-yellow-700">â†’</button>
                </div>
            </div>
            
            <!-- ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼/ã‚¯ãƒªã‚¢å¾Œã®ãƒœã‚¿ãƒ³ -->
            <button id="retryButton" class="btn-red p-4 rounded-xl text-lg md:text-xl font-bold hover:scale-105 transform transition duration-200 hidden">ãƒªãƒˆãƒ©ã‚¤</button>
        </div>
    </div>

    <script>
        window.onload = function() {
            const canvas = document.getElementById('gameCanvas');
            const ctx = canvas.getContext('2d');
            
            // UIè¦ç´ ã‚’å–å¾—
            const startButton = document.getElementById('startButton');
            const retryButton = document.getElementById('retryButton');
            const gameIntro = document.getElementById('game-intro');
            const gameUI = document.getElementById('game-ui');
            const gameMessage = document.getElementById('game-message');
            const eatBananaContainer = document.getElementById('eat-banana-container');
            const eatCountDisplay = document.getElementById('eat-count-display');
            const difficultySelect = document.getElementById('difficulty');
            const joystick = document.getElementById('joystick');
            const joystickHandle = document.getElementById('joystick-handle');
            const rhythmIntroContainer = document.getElementById('rhythm-intro-container');
            const rhythmStartButton = document.getElementById('rhythmStartButton');
            
            // ãƒªã‚ºãƒ ã‚²ãƒ¼ãƒ ã®ãƒ¬ãƒ¼ãƒ³ãƒœã‚¿ãƒ³ã‚’å–å¾—
            const laneButtonLeft = document.getElementById('laneButtonLeft');
            const laneButtonCenter = document.getElementById('laneButtonCenter');
            const laneButtonRight = document.getElementById('laneButtonRight');
            
            let animationFrameId;
            let startTime;
            let endTime;
            
            // ã‚°ãƒ­ãƒ¼ãƒãƒ«ãªã‚²ãƒ¼ãƒ è¨­å®š
            let gameState = 'title'; // 'title', 'playing', 'rhythmIntro', 'rhythmGame', 'gameOver', 'win'
            let player = { x: 0, y: 0, size: 20, speed: 5 };

            // BGMé–¢é€£ã®å¤‰æ•°
            let gameBGM;
            // ğŸ’¡ ãƒ¦ãƒ¼ã‚¶ãƒ¼æä¾›ã®GitHub Raw URLã«æ›´æ–°
            const BGM_URL = 'https://raw.githubusercontent.com/yoshikawagames/banana-thief/main/%E6%8E%A5%E7%9D%80%E5%89%A4%E3%81%A8%E7%86%B1%E5%B8%AF%E3%81%AE%E5%BE%8C.mp3'; 
            
            // ã‚¸ãƒ§ã‚¤ã‚¹ãƒ†ã‚£ãƒƒã‚¯é–¢é€£
            let joystickActive = false;
            let joystickCenter = { x: 0, y: 0 };
            let joystickVector = { x: 0, y: 0 };
            let joystickDistance = 0;
            
            const banana = { x: 0, y: 0, width: 30, height: 60 };
            const eatMax = 10;
            
            const guards = [
                { x: 0, y: 0, size: 30, color: '#3B82F6' },
                { x: 0, y: 0, size: 30, color: '#3B82F6' }
            ];
            const visitors = [
                { x: 0, y: 0, size: 20, color: '#9CA3AF' },
                { x: 0, y: 0, size: 20, color: '#9CA3AF' },
                { x: 0, y: 0, size: 20, color: '#9CA3AF' }
            ];
            let bullets = []; 
            let bulletSpeed = 2; 
            let bulletInterval = 50; 
            let visitorBulletInterval = 120;
            let visitorBulletDirection = []; 
            let frameCount = 0;
            const bulletSize = 10;
            let initialBulletFired = false;

            // ãƒªã‚ºãƒ ã‚²ãƒ¼ãƒ å¤‰æ•°
            let rhythmNotes = [];
            let noteSpeed = 2;
            let noteInterval = 60;
            let noteAcceleration = 0; // ãƒãƒ¼ãƒˆé€Ÿåº¦ã®åŠ é€Ÿ
            let noteIntervalReduction = 0; // ãƒãƒ¼ãƒˆé–“éš”ã®çŸ­ç¸®
            const hitZoneHeight = 50;
            // ã‚¿ãƒƒãƒ—åˆ¤å®šã‚¨ãƒªã‚¢ï¼ˆé»„è‰²ã„ã‚¾ãƒ¼ãƒ³ï¼‰ã‚’å°‘ã—ä¸Šã«ç§»å‹•
            let rhythmHitZoneY; 
            const hitZoneColor = 'rgba(255, 204, 0, 0.5)';
            const rhythmLanes = ['left', 'center', 'right'];
            let rhythmScore = 0;
            
            // ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚’ç”»é¢ã‚µã‚¤ã‚ºã«åˆã‚ã›ã‚‹
            function resizeCanvas() {
                canvas.width = window.innerWidth > 768 ? 800 : window.innerWidth * 0.9;
                canvas.height = canvas.width * 0.8;
                rhythmHitZoneY = canvas.height - 150; // ãƒ’ãƒƒãƒˆã‚¾ãƒ¼ãƒ³ã®Yåº§æ¨™ã‚’å†è¨ˆç®—
            }
            window.addEventListener('resize', resizeCanvas);
            resizeCanvas();

            // ã‚²ãƒ¼ãƒ ã®åˆæœŸçŠ¶æ…‹ã‚’è¨­å®š
            function initGame() {
                const difficulty = difficultySelect.value;
                console.log('initGame called. Difficulty:', difficulty);
                
                // ãƒ‡ãƒãƒƒã‚°ãƒ¢ãƒ¼ãƒ‰ã¯ã“ã“ã‚’ã‚¹ã‚­ãƒƒãƒ—ã™ã‚‹
                if (difficulty === 'debug' && gameState === 'rhythmIntro') {
                    // ãƒ‡ãƒãƒƒã‚°ãƒ¢ãƒ¼ãƒ‰ã§ã¯ã€ã‚²ãƒ¼ãƒ ã®ãƒ¡ã‚¤ãƒ³éƒ¨åˆ†ã‚’ã‚¹ã‚­ãƒƒãƒ—
                    return;
                }

                if (difficulty === 'easy') {
                    bulletSpeed = 1.5;
                    bulletInterval = 60;
                    visitorBulletInterval = 150;
                    player.speed = 6;
                    noteAcceleration = 0; // ã‹ã‚“ãŸã‚“ãƒ¢ãƒ¼ãƒ‰ã§ã¯é€Ÿåº¦å¤‰åŒ–ãªã—
                    noteIntervalReduction = 0;
                } else if (difficulty === 'normal') {
                    bulletSpeed = 2.5;
                    bulletInterval = 40;
                    visitorBulletInterval = 100;
                    player.speed = 5;
                    noteAcceleration = 0.0001; // æ™®é€šãƒ¢ãƒ¼ãƒ‰ã®ãƒãƒ¼ãƒˆåŠ é€Ÿã‚’ç·©ã‚„ã‹ã«
                    noteIntervalReduction = 0.02; // æ™®é€šãƒ¢ãƒ¼ãƒ‰ã®ãƒãƒ¼ãƒˆé–“éš”çŸ­ç¸®ã‚’ç·©ã‚„ã‹ã«
                } else if (difficulty === 'hard') {
                    bulletSpeed = 3.5;
                    bulletInterval = 25;
                    visitorBulletInterval = 60;
                    player.speed = 4;
                    noteAcceleration = 0.001; // ã‚€ãšã‹ã—ã„ãƒ¢ãƒ¼ãƒ‰ã§ã‚ˆã‚ŠåŠ é€Ÿ
                    noteIntervalReduction = 0.1;
                }

                player.x = canvas.width / 2;
                player.y = canvas.height - 50;
                
                banana.x = canvas.width / 2 - banana.width / 2;
                banana.y = 50;
                
                guards[0].x = canvas.width / 4;
                guards[0].y = 100;
                guards[1].x = canvas.width * 3 / 4;
                guards[1].y = 100;
                
                visitors[0].x = canvas.width / 8;
                visitors[0].y = canvas.height / 2;
                visitors[1].x = canvas.width / 2;
                visitors[1].y = canvas.height / 2.5;
                visitors[2].x = canvas.width * 7 / 8;
                visitors[2].y = canvas.height / 2;

                bullets = [];
                rhythmNotes = [];
                rhythmScore = 0;
                frameCount = 0;
                initialBulletFired = false;
                
                // ãƒªã‚ºãƒ ã‚²ãƒ¼ãƒ ã®åˆæœŸé€Ÿåº¦ã‚’ãƒªã‚»ãƒƒãƒˆ
                noteSpeed = 2;
                noteInterval = 60;

                startTime = performance.now();

                visitorBulletDirection = visitors.map(() => {
                    const angle = Math.random() * Math.PI * 2;
                    return { dx: Math.cos(angle), dy: Math.sin(angle) };
                });
            }
            
            // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ï¼ˆæ€ªç›—ï¼‰ã®ãƒ‰ãƒƒãƒˆçµµã‚’æç”»
            function drawPlayer() {
                const s = player.size / 4; // ãƒ‰ãƒƒãƒˆã®ã‚µã‚¤ã‚º
                const x = player.x - player.size / 2;
                const y = player.y - player.size / 2;
                
                // è¼ªéƒ­ (ç™½ã„ç·šã§ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼å…¨ä½“ã‚’å›²ã‚€)
                ctx.strokeStyle = '#FFFFFF'; 
                ctx.lineWidth = 2; 
                ctx.strokeRect(x - 1, y - 1, player.size + 2, player.size + 2);

                // é ­ (å¸½å­ã¨é¡”)
                ctx.fillStyle = '#000000'; // å¸½å­
                ctx.fillRect(x, y, s * 4, s * 2);
                ctx.fillRect(x + s, y + s * 2, s * 2, s);
                ctx.fillStyle = '#C0C0C0'; // é¡”
                ctx.fillRect(x + s, y + s * 3, s * 2, s);
                
                // ä½“
                ctx.fillStyle = '#333333'; // ã‚¹ãƒ¼ãƒ„
                ctx.fillRect(x + s, y + s * 4, s * 2, s * 3);
                ctx.fillRect(x, y + s * 5, s, s);
                ctx.fillRect(x + s * 3, y + s * 5, s, s);
            }
            
            // è­¦å‚™å“¡ã®ãƒ‰ãƒƒãƒˆçµµã‚’æç”»
            function drawGuards() {
                guards.forEach(guard => {
                    const s = guard.size / 4;
                    const x = guard.x - guard.size / 2;
                    const y = guard.y - guard.size / 2;
                    
                    // è¼ªéƒ­ (ç™½ã„ç·šã§è­¦å‚™å“¡å…¨ä½“ã‚’å›²ã‚€)
                    ctx.strokeStyle = '#FFFFFF'; 
                    ctx.lineWidth = 2; 
                    ctx.strokeRect(x - 1, y - 1, guard.size + 2, guard.size + 2);

                    // å¸½å­
                    ctx.fillStyle = '#0000FF'; // é’ã„å¸½å­
                    ctx.fillRect(x, y, s * 4, s * 2);
                    
                    // é¡”
                    ctx.fillStyle = '#E6E6E6';
                    ctx.fillRect(x + s, y + s * 2, s * 2, s * 2);
                    
                    // ä½“
                    ctx.fillStyle = '#0000FF'; // é’ã„åˆ¶æœ
                    ctx.fillRect(x, y + s * 4, s * 4, s * 3);
                });
            }
            
            // è¨ªå•è€…ã®ãƒ‰ãƒƒãƒˆçµµã‚’æç”»
            function drawVisitors() {
                visitors.forEach(visitor => {
                    const s = visitor.size / 4;
                    const x = visitor.x - visitor.size / 2;
                    const y = visitor.y - visitor.size / 2;
                    
                    // è¼ªéƒ­ (ç™½ã„ç·šã§è¨ªå•è€…å…¨ä½“ã‚’å›²ã‚€)
                    ctx.strokeStyle = '#FFFFFF'; 
                    ctx.lineWidth = 2; 
                    ctx.strokeRect(x - 1, y - 1, visitor.size + 2, visitor.size + 2);
                    
                    // ä½“
                    ctx.fillStyle = visitor.color;
                    ctx.fillRect(x, y + s * 3, s * 4, s * 4);
                    
                    // é ­
                    ctx.fillStyle = '#F08080';
                    ctx.fillRect(x + s, y, s * 2, s * 2);
                });
            }

            // ãƒãƒŠãƒŠã®ãƒ‰ãƒƒãƒˆçµµã‚’æç”»
            function drawBanana() {
                const x = banana.x;
                const y = banana.y;
                const w = banana.width;
                const h = banana.height;

                ctx.fillStyle = '#A8A29E'; // å°åº§
                ctx.fillRect(x, y, w, h / 10);
                
                // ãƒãƒŠãƒŠæœ¬ä½“ã®ãƒ‰ãƒƒãƒˆçµµ
                ctx.fillStyle = '#FDE047'; // é»„è‰²
                ctx.fillRect(x + w / 4, y + h / 10, w / 2, h * 0.9);
                ctx.fillRect(x + w * 0.2, y + h * 0.3, w * 0.6, h * 0.4);

                ctx.fillStyle = '#EAB308'; // å½±
                ctx.fillRect(x + w * 0.5, y + h * 0.2, w * 0.1, h * 0.7);
            }

            // å¼¾ï¼ˆè¦–ç·šï¼‰ã‚’æç”»
            function drawBullets() {
                bullets.forEach(bullet => {
                    // è¼ªéƒ­ã®è¨­å®š
                    ctx.strokeStyle = '#000000'; // é»’ã„è¼ªéƒ­
                    ctx.lineWidth = 2; // è¼ªéƒ­ã®å¤ªã•

                    ctx.fillStyle = '#EF4444'; // èµ¤ã„ãƒ“ãƒ¼ãƒ 
                    ctx.beginPath();
                    ctx.moveTo(bullet.x, bullet.y);
                    ctx.lineTo(bullet.x + bullet.width, bullet.y + bullet.height / 2);
                    ctx.lineTo(bullet.x, bullet.y + bullet.height);
                    ctx.closePath(); // ãƒ‘ã‚¹ã‚’é–‰ã˜ã‚‹
                    ctx.fill();
                    ctx.stroke(); // å¡—ã‚Šã®å¾Œã«è¼ªéƒ­ã‚’æç”»
                });
            }
            
            function createInitialBullet() {
                if (frameCount === 30 && !initialBulletFired) {
                    const dx1 = player.x - guards[0].x;
                    const dy1 = player.y - guards[0].y;
                    const angle1 = Math.atan2(dy1, dx1);
                    bullets.push({
                        x: guards[0].x,
                        y: guards[0].y,
                        dx: Math.cos(angle1) * bulletSpeed * 1.5,
                        dy: Math.sin(angle1) * bulletSpeed * 1.5,
                        width: bulletSize,
                        height: bulletSize
                    });
                    
                    const dx2 = player.x - guards[1].x;
                    const dy2 = player.y - guards[1].y;
                    const angle2 = Math.atan2(dy2, dx2);
                    bullets.push({
                        x: guards[1].x,
                        y: guards[1].y,
                        dx: Math.cos(angle2) * bulletSpeed * 1.5,
                        dy: Math.sin(angle2) * bulletSpeed * 1.5,
                        width: bulletSize,
                        height: bulletSize
                    });
                    
                    initialBulletFired = true;
                }
            }

            function createGuardBulletPattern() {
                const difficulty = difficultySelect.value;
                
                if (difficulty === 'normal' || difficulty === 'hard') {
                    if (frameCount % (bulletInterval * 2) === 0) {
                        const angle = Math.PI * 0.5;
                        const spread = 0.2;
                        guards.forEach(guard => {
                            for(let i = -1; i <= 1; i++) {
                                const bulletAngle = angle + (i * spread);
                                bullets.push({
                                    x: guard.x,
                                    y: guard.y,
                                    dx: Math.cos(bulletAngle) * bulletSpeed * 1.5,
                                    dy: Math.sin(bulletAngle) * bulletSpeed * 1.5,
                                    width: bulletSize,
                                    height: bulletSize
                                });
                            }
                        });
                    }
                }
                
                if (frameCount % bulletInterval === 0) {
                    const angleStep = Math.PI * 2 / 10;
                    guards.forEach(guard => {
                        for (let i = 0; i < 10; i++) {
                            const angle = i * angleStep;
                            bullets.push({
                                x: guard.x,
                                y: guard.y,
                                dx: Math.cos(angle) * bulletSpeed,
                                dy: Math.sin(angle) * bulletSpeed,
                                width: bulletSize,
                                height: bulletSize
                            });
                        }
                    });
                }
            }

            function createVisitorBulletPattern() {
                if (frameCount % visitorBulletInterval === 0) {
                    const difficulty = difficultySelect.value;
                    visitors.forEach((visitor, index) => {
                        let dx, dy;
                        if (difficulty === 'hard') {
                            dx = player.x - visitor.x;
                            dy = player.y - visitor.y;
                            const angle = Math.atan2(dy, dx);
                            dx = Math.cos(angle) * bulletSpeed * 1.2;
                            dy = Math.sin(angle) * bulletSpeed * 1.2;
                        } else {
                            dx = visitorBulletDirection[index].dx * bulletSpeed * 1.2;
                            dy = visitorBulletDirection[index].dy * bulletSpeed * 1.2;
                        }
                        
                        bullets.push({
                            x: visitor.x,
                            y: visitor.y,
                            dx: dx,
                            dy: dy,
                            width: bulletSize,
                            height: bulletSize
                        });
                    });
                }
            }

            function moveBullets() {
                bullets.forEach(bullet => {
                    bullet.x += bullet.dx;
                    bullet.y += bullet.dy;
                });
                bullets = bullets.filter(bullet =>
                    bullet.x > -bulletSize &&
                    bullet.x < canvas.width + bulletSize &&
                    bullet.y > -bulletSize &&
                    bullet.y < canvas.height + bulletSize
                );
            }

            function checkCollision() {
                for (const bullet of bullets) {
                    const dx = player.x - (bullet.x + bullet.width / 2);
                    const dy = player.y - (bullet.y + bullet.height / 2);
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    if (distance < player.size / 2 + bullet.width / 2) {
                        return true;
                    }
                }
                return false;
            }
            
            function checkBananaProximity() {
                const dx = player.x - (banana.x + banana.width / 2);
                const dy = player.y - (banana.y + banana.height / 2);
                const distance = Math.sqrt(dx * dx + dy * dy);
                return distance < player.size + 20;
            }
            
            // --- ãƒªã‚ºãƒ ã‚²ãƒ¼ãƒ é–¢æ•° ---

            // ãƒªã‚ºãƒ ãƒãƒ¼ãƒˆã‚’ç”Ÿæˆ
            function createRhythmNotes() {
                const difficulty = difficultySelect.value;
                const currentNoteInterval = Math.max(20, noteInterval - frameCount * noteIntervalReduction);

                if (frameCount % Math.floor(currentNoteInterval) === 0 && (rhythmNotes.length < eatMax || difficulty === 'debug')) {
                    let noteX;
                    if (difficulty === 'easy') {
                        noteX = canvas.width / 2; // ã‹ã‚“ãŸã‚“ãƒ¢ãƒ¼ãƒ‰ã¯ä¸­å¤®ã®ã¿
                    } else {
                        // ãµã¤ã†/ã‚€ãšã‹ã—ã„/ãƒ‡ãƒãƒƒã‚°ãƒ¢ãƒ¼ãƒ‰ã¯3ã¤ã®ãƒ¬ãƒ¼ãƒ³
                        const laneWidth = canvas.width / 3;
                        const laneIndex = Math.floor(Math.random() * 3);
                        noteX = laneWidth * (laneIndex + 0.5);
                    }
                    rhythmNotes.push({
                        x: noteX,
                        y: 0,
                        size: 30,
                        lane: rhythmLanes[Math.floor(noteX / (canvas.width / 3))]
                    });
                }
            }
            
            // ãƒªã‚ºãƒ ã‚²ãƒ¼ãƒ ã®åˆæœŸè¨­å®š
            function initRhythmGame() {
                rhythmNotes = [];
                rhythmScore = 0;
                frameCount = 0;
                const difficulty = difficultySelect.value;
                if (difficulty === 'easy') {
                    noteSpeed = 1.5; // ã‹ã‚“ãŸã‚“ãƒ¢ãƒ¼ãƒ‰ã¯ã•ã‚‰ã«ã‚†ã£ãã‚Š
                    noteInterval = 80;
                    noteAcceleration = 0;
                    noteIntervalReduction = 0;
                } else if (difficulty === 'normal') {
                    noteSpeed = 2; // æ™®é€šãƒ¢ãƒ¼ãƒ‰ã®ãƒãƒ¼ãƒˆé€Ÿåº¦ã‚’èª¿æ•´
                    noteInterval = 70; // æ™®é€šãƒ¢ãƒ¼ãƒ‰ã®ãƒãƒ¼ãƒˆé–“éš”ã‚’èª¿æ•´
                    noteAcceleration = 0.0001; // æ™®é€šãƒ¢ãƒ¼ãƒ‰ã®ãƒãƒ¼ãƒˆåŠ é€Ÿã‚’ç·©ã‚„ã‹ã«
                    noteIntervalReduction = 0.02; // æ™®é€šãƒ¢ãƒ¼ãƒ‰ã®ãƒãƒ¼ãƒˆé–“éš”çŸ­ç¸®ã‚’ç·©ã‚„ã‹ã«
                } else if (difficulty === 'hard') {
                    noteSpeed = 2.5; // ã‚€ãšã‹ã—ã„ãƒ¢ãƒ¼ãƒ‰ã®ãƒãƒ¼ãƒˆé€Ÿåº¦ã‚’èª¿æ•´
                    noteInterval = 50;
                    noteAcceleration = 0.001;
                    noteIntervalReduction = 0.1;
                } else if (difficulty === 'debug') {
                    noteSpeed = 2;
                    noteInterval = 60;
                    noteAcceleration = 0;
                    noteIntervalReduction = 0;
                }
            }


            // ãƒªã‚ºãƒ ãƒãƒ¼ãƒˆã‚’ç§»å‹•
            function moveRhythmNotes() {
                const currentNoteSpeed = noteSpeed + frameCount * noteAcceleration;
                rhythmNotes.forEach(note => {
                    note.y += currentNoteSpeed;
                });

                let notesPassed = false;
                rhythmNotes = rhythmNotes.filter(note => {
                    if (note.y > rhythmHitZoneY + hitZoneHeight + 20) { // ã‚¿ãƒƒãƒåˆ¤å®šã‚’å°‘ã—ç”˜ã
                        notesPassed = true;
                        return false;
                    }
                    return true;
                });
                
                if (notesPassed && difficultySelect.value !== 'debug') {
                     gameState = 'gameOver';
                     endTime = performance.now();
                }
            }

            // ãƒªã‚ºãƒ ã‚²ãƒ¼ãƒ ã®è¦ç´ ã‚’æç”»
            function drawRhythmGame() {
                // èƒŒæ™¯ç”»åƒãŒã‚ã‚‹ãŸã‚ã€ã‚­ãƒ£ãƒ³ãƒã‚¹å…¨ä½“ã‚’ã‚¯ãƒªã‚¢ã›ãšã€ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãªã©ãŒæç”»ã•ã‚Œã¦ã„ãªã„é ˜åŸŸã‚’å‡¦ç†
                // ãƒãƒ¼ãƒˆã¨ãƒ’ãƒƒãƒˆã‚¾ãƒ¼ãƒ³ã®ã¿æç”»
                
                // ãƒ’ãƒƒãƒˆã‚¾ãƒ¼ãƒ³
                ctx.fillStyle = hitZoneColor;
                ctx.fillRect(0, rhythmHitZoneY, canvas.width, hitZoneHeight);
                
                // ãƒãƒ¼ãƒˆ
                ctx.fillStyle = '#6D28D9';
                rhythmNotes.forEach(note => {
                    ctx.fillRect(note.x - note.size / 2, note.y - note.size / 2, note.size, note.size);
                });
            }

            // ãƒªã‚ºãƒ ã‚¿ãƒƒãƒ—ã‚’å‡¦ç†
            function handleRhythmTap(lane) {
                let hit = false;
                const hitMargin = 30; // ã‚¿ãƒƒãƒåˆ¤å®šã®ä½™è£•
                for (let i = rhythmNotes.length - 1; i >= 0; i--) {
                    const note = rhythmNotes[i];
                    if (note.lane === lane && note.y > rhythmHitZoneY - hitMargin && note.y < rhythmHitZoneY + hitZoneHeight + hitMargin) {
                        rhythmScore++;
                        rhythmNotes.splice(i, 1);
                        hit = true;
                        break;
                    }
                }

                if (!hit && difficultySelect.value !== 'debug') {
                    gameState = 'gameOver';
                    endTime = performance.now();
                }

                if (rhythmScore >= eatMax) {
                    gameState = 'win';
                    endTime = performance.now();
                }
            }

            // ã‚²ãƒ¼ãƒ ãƒ«ãƒ¼ãƒ—
            function gameLoop() {
                // ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚’ã‚¯ãƒªã‚¢ï¼ˆèƒŒæ™¯ç”»åƒã®ä¸Šã‹ã‚‰æç”»ã™ã‚‹ãŸã‚ï¼‰
                // èƒŒæ™¯ç”»åƒã¯CSSã§è¨­å®šã•ã‚Œã¦ã„ã‚‹ãŸã‚ã€ã“ã“ã§ã¯æç”»ã•ã‚Œã‚‹è¦ç´ ã ã‘ã‚’æç”»
                ctx.clearRect(0, 0, canvas.width, canvas.height); 
                
                if (gameState === 'playing') {
                    frameCount++;
                    if (joystickActive) {
                        // éç·šå½¢ãªé€Ÿåº¦èª¿æ•´ (joystickDistanceã®2ä¹—)
                        const speedFactor = joystickDistance * joystickDistance;
                        player.x += joystickVector.x * player.speed * speedFactor;
                        player.y += joystickVector.y * player.speed * speedFactor;
                        player.x = Math.max(player.size / 2, Math.min(canvas.width - player.size / 2, player.x));
                        player.y = Math.max(player.size / 2, Math.min(canvas.height - player.size / 2, player.y));
                    }
                    createInitialBullet();
                    createGuardBulletPattern();
                    createVisitorBulletPattern();
                    moveBullets();
                    if (checkCollision()) {
                        gameState = 'gameOver';
                        endTime = performance.now();
                    }
                    if (checkBananaProximity()) {
                        gameState = 'rhythmIntro';
                    }
                } else if (gameState === 'rhythmGame') {
                    frameCount++;
                    createRhythmNotes();
                    moveRhythmNotes();
                    drawRhythmGame();
                }

                if (gameState === 'playing') {
                    drawPlayer();
                    drawGuards();
                    drawVisitors();
                    drawBanana();
                    drawBullets();
                }

                updateUI();
                
                animationFrameId = requestAnimationFrame(gameLoop);
            }

            // UIè¦ç´ ã®æ›´æ–°
            function updateUI() {
                gameUI.classList.add('hidden');
                eatBananaContainer.classList.add('hidden');
                retryButton.classList.add('hidden');
                joystick.classList.add('hidden');
                rhythmIntroContainer.classList.add('hidden');
                
                switch(gameState) {
                    case 'title':
                        // ã‚¿ã‚¤ãƒˆãƒ«ç”»é¢ã§ã¯BGMã‚’åœæ­¢
                        gameBGM.pause();
                        gameBGM.currentTime = 0;
                        gameIntro.classList.remove('hidden');
                        break;
                    case 'playing':
                        gameIntro.classList.add('hidden');
                        gameUI.classList.remove('hidden');
                        joystick.classList.remove('hidden');
                        gameMessage.textContent = '';
                        break;
                    case 'rhythmIntro':
                        // ãƒªã‚ºãƒ ã‚²ãƒ¼ãƒ ã®èª¬æ˜ä¸­ã¯BGMã‚’ä¸€æ™‚åœæ­¢
                        gameBGM.pause();
                        gameIntro.classList.add('hidden');
                        rhythmIntroContainer.classList.remove('hidden');
                        joystick.classList.add('hidden');
                        cancelAnimationFrame(animationFrameId);
                        break;
                    case 'rhythmGame':
                        // ãƒªã‚ºãƒ ã‚²ãƒ¼ãƒ ä¸­ã¯BGMã‚’å†ç”Ÿç¶™ç¶šï¼ˆã“ã“ã§ã¯ä¸€æ™‚åœæ­¢å‡¦ç†ãªã—ï¼‰
                        gameIntro.classList.add('hidden');
                        gameUI.classList.remove('hidden');
                        eatBananaContainer.classList.remove('hidden');
                        gameMessage.textContent = 'ãƒªã‚ºãƒ ã‚ˆãã‚¿ãƒƒãƒ—ã—ã¦é£Ÿã¹ã‚ï¼';
                        eatCountDisplay.textContent = `é£Ÿã¹ãŸãƒãƒŠãƒŠ... ${rhythmScore}/${eatMax}`;
                        joystick.classList.add('hidden');
                        break;
                    case 'gameOver':
                    case 'win':
                        // ã‚²ãƒ¼ãƒ çµ‚äº†æ™‚ã¯BGMã‚’åœæ­¢
                        gameBGM.pause();
                        gameBGM.currentTime = 0;
                        if (rhythmScore >= 5) {
                            gameMessage.textContent = 'é€®æ•ã•ã‚ŒãŸã‘ã©ãƒãƒŠãƒŠã®å®Ÿã¯é£Ÿã¹ãŸï¼';
                        } else if (rhythmScore > 0) {
                            gameMessage.textContent = 'é€®æ•ã•ã‚ŒãŸã‘ã©ã‚¬ãƒ ãƒ†ãƒ¼ãƒ—ã ã‘é£Ÿã¹ãŸï¼';
                        } else {
                            gameMessage.textContent = 'é€®æ•ã•ã‚ŒãŸï¼ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼';
                        }
                        gameUI.classList.remove('hidden');
                        retryButton.classList.remove('hidden');
                        cancelAnimationFrame(animationFrameId);
                        break;
                }
            }

            // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼
            joystick.addEventListener('touchstart', (e) => {
                if (gameState === 'playing') {
                    e.preventDefault();
                    joystickActive = true;
                    const rect = joystick.getBoundingClientRect();
                    joystickCenter = { x: rect.left + rect.width / 2, y: rect.top + rect.height / 2 };
                    updateJoystick(e.touches[0].clientX, e.touches[0].clientY);
                }
            });

            joystick.addEventListener('touchmove', (e) => {
                if (joystickActive) {
                    e.preventDefault();
                    updateJoystick(e.touches[0].clientX, e.touches[0].clientY);
                }
            });

            joystick.addEventListener('touchend', () => {
                joystickActive = false;
                joystickVector = { x: 0, y: 0 };
                joystickDistance = 0;
                joystickHandle.style.transform = 'translate(0, 0)';
            });

            function updateJoystick(touchX, touchY) {
                const dx = touchX - joystickCenter.x;
                const dy = touchY - joystickCenter.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                const maxDistance = joystick.clientWidth / 2;

                joystickDistance = Math.min(distance / maxDistance, 1);

                if (distance > maxDistance) {
                    const angle = Math.atan2(dy, dx);
                    joystickVector.x = Math.cos(angle);
                    joystickVector.y = Math.sin(angle);
                    joystickHandle.style.transform = `translate(${joystickVector.x * maxDistance}px, ${joystickVector.y * maxDistance}px)`;
                } else {
                    joystickVector.x = dx / maxDistance;
                    joystickVector.y = dy / maxDistance;
                    joystickHandle.style.transform = `translate(${dx}px, ${dy}px)`;
                }
            }

            startButton.addEventListener('click', () => {
                const difficulty = difficultySelect.value;
                if (difficulty === 'debug') {
                    gameState = 'rhythmIntro';
                    updateUI();
                } else {
                    // BGMå†ç”Ÿé–‹å§‹ (ãƒ–ãƒ©ã‚¦ã‚¶ã®è‡ªå‹•å†ç”Ÿãƒãƒªã‚·ãƒ¼ã®ãŸã‚ã€ãƒ¦ãƒ¼ã‚¶ãƒ¼æ“ä½œã§é–‹å§‹)
                    gameBGM.currentTime = 0; // æ›²ã®æœ€åˆã«æˆ»ã—ã¦ã‹ã‚‰å†ç”Ÿ
                    gameBGM.play().catch(error => {
                        console.error("BGMã®å†ç”Ÿã«å¤±æ•—ã—ã¾ã—ãŸ (ãƒ¦ãƒ¼ã‚¶ãƒ¼æ“ä½œãŒå¿…è¦):", error);
                    }); 
                    
                    gameState = 'playing';
                    initGame();
                    gameLoop();
                }
            });

            rhythmStartButton.addEventListener('click', () => {
                gameState = 'rhythmGame';
                initRhythmGame();
                // ãƒªã‚ºãƒ ã‚²ãƒ¼ãƒ é–‹å§‹æ™‚ã‚‚BGMã‚’å†ç”Ÿï¼ˆä¸€æ™‚åœæ­¢ã—ã¦ã„ãŸå ´åˆã®ãŸã‚ï¼‰
                gameBGM.play().catch(error => console.error("BGMå†é–‹ã«å¤±æ•—:", error));
                gameLoop();
            });
            
            retryButton.addEventListener('click', () => {
                gameState = 'playing';
                initGame();
                gameBGM.currentTime = 0; // BGMã‚’æœ€åˆã«æˆ»ã™
                gameBGM.play().catch(error => console.error("BGMå†é–‹ã«å¤±æ•—:", error));
                gameLoop();
            });
            
            laneButtonLeft.addEventListener('click', () => {
                if (gameState === 'rhythmGame') handleRhythmTap('left');
            });
            laneButtonCenter.addEventListener('click', () => {
                if (gameState === 'rhythmGame') handleRhythmTap('center');
            });
            laneButtonRight.addEventListener('click', () => {
                if (gameState === 'rhythmGame') handleRhythmTap('right');
            });


            // BGMã®åˆæœŸè¨­å®š
            gameBGM = new Audio(BGM_URL);
            gameBGM.loop = true; // ãƒ«ãƒ¼ãƒ—ã‚’æœ‰åŠ¹ã«ã™ã‚‹
            gameBGM.volume = 0.2; // éŸ³é‡ã‚’å°‘ã—ä¸‹ã’ã‚‹ (ä»»æ„)


            // åˆæœŸæç”»
            initGame();
            updateUI();
        };
    </script>
</body>
</html>
